{"ast":null,"code":"import * as coll from \"./collision\";\nimport * as conf from \"./conf\";\nexport const initModel = () => {\n  return {\n    triangles: [],\n    circles: [],\n    startSelec: null,\n    endSelec: null,\n    events: []\n  };\n}; // Fonctions pour creer et ajouter des triangles et cercles dans le modele\n\nconst addTriangle = (model, triangle) => {\n  return {\n    triangles: model.triangles.concat(triangle),\n    circles: model.circles,\n    startSelec: model.startSelec,\n    endSelec: model.endSelec,\n    events: model.events\n  };\n};\n\nconst addCircle = (model, circle) => {\n  return {\n    triangles: model.triangles,\n    circles: model.circles.concat(circle),\n    startSelec: model.startSelec,\n    endSelec: model.endSelec,\n    events: model.events\n  };\n};\n/*******************************************************************\n     * Fonctions de déplacement\n*******************************************************************/\n\n\nexport const selectTrianglesInArea = (start, end, modele) => {\n  // Sélectionne les triangles dans la zone spécifiée par l'utilisateur\n  const selectionRect = {\n    x1: Math.min(start.x, end.x),\n    y1: Math.min(start.y, end.y),\n    x2: Math.max(start.x, end.x),\n    y2: Math.max(start.y, end.y)\n  };\n  const newtriangles = modele.triangles.map(triangle => {\n    const centerX = triangle.center.x;\n    const centerY = triangle.center.y;\n    const selected = centerX >= selectionRect.x1 && centerX <= selectionRect.x2 && centerY >= selectionRect.y1 && centerY <= selectionRect.y2; //if (triangle.destination == null) return createTriangle(triangle.points, triangle.size, triangle.center, triangle.color, selected, null);\n\n    const newTriangle = {\n      points: triangle.points,\n      size: triangle.size,\n      center: triangle.center,\n      color: triangle.color,\n      selected: selected,\n      destination: triangle.destination\n    };\n    return newTriangle;\n  });\n  return {\n    triangles: newtriangles,\n    circles: modele.circles,\n    startSelec: null,\n    endSelec: null,\n    events: modele.events\n  };\n}; // Réoriente le triangle pour qu'il pointe vers la destination\n\nconst reorientTriangle = triangle => {\n  const center = triangle.center; // Utilisez le centre précalculé pour la rotation\n\n  const destination = triangle.destination; // Si aucune destination n'est définie, retournez le triangle tel quel théoriquement impossible mais vérification obligatoire\n\n  if (!destination) return triangle; // Calculez l'angle de direction vers la destination\n\n  const angleToDestination = Math.atan2(destination.y - center.y, destination.x - center.x); // Calculez l'angle actuel du sommet supérieur par rapport au centre\n\n  const currentTop = triangle.points[0]; // Le sommet supérieur est toujours le premier point\n\n  const angleCurrentTop = Math.atan2(currentTop.y - center.y, currentTop.x - center.x); // Calculez l'angle de rotation nécessaire\n\n  let rotationAngle = angleToDestination - angleCurrentTop; // Appliquez la rotation à chaque point du triangle\n\n  const newpoints = triangle.points.map(point => {\n    const dx = point.x - center.x;\n    const dy = point.y - center.y;\n    return {\n      x: center.x + dx * Math.cos(rotationAngle) - dy * Math.sin(rotationAngle),\n      y: center.y + dx * Math.sin(rotationAngle) + dy * Math.cos(rotationAngle)\n    };\n  });\n  const newTriangle = {\n    points: newpoints,\n    size: triangle.size,\n    center: triangle.center,\n    color: triangle.color,\n    selected: triangle.selected,\n    destination: triangle.destination\n  };\n  return newTriangle;\n};\n\nconst collisionsGestion = (triangle, circle) => {\n  if (this.collision.checkCollisionWithCircle(triangle, circle)) {\n    if (triangle.color === circle.color) {\n      circle.hp += 1; // Augmente les points de vie du cercle\n\n      console.log(\"test\");\n    } else {\n      circle.hp -= 1; // Réduit les points de vie du cercle\n\n      if (circle.hp <= 0) {\n        circle.color = triangle.color; // Change la couleur du cercle à celle du triangle\n\n        circle.hp = 10; // Réinitialise les points de vie\n      }\n\n      console.log(\"test2\");\n    } //console.log(this.checkCollisionWithCircle(triangle, circle));\n\n\n    return false; // Supprime le triangle en cas de collision\n  } else return true; // Garde le triangle s'il n'y a pas de collision\n\n};\n\nconst moveTriangles = model => {\n  const newtriangles = model.triangles.filter(triangle => {\n    let keepTriangle = true;\n\n    if (triangle.destination) {\n      // Ignore les triangles non sélectionnés ou immobiles\n      // Calcul de la direction et de la distance vers la destination\n      const dx = triangle.destination.x - triangle.center.x;\n      const dy = triangle.destination.y - triangle.center.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const angle = Math.atan2(dy, dx);\n\n      if (distance < 1) {\n        triangle.destination = null; // Réinitialise la destination\n\n        return keepTriangle; // Le triangle reste présent\n      }\n\n      const speed = 1; // Vitesse de déplacement\n\n      triangle.points.forEach(point => {\n        point.x += Math.cos(angle) * speed;\n        point.y += Math.sin(angle) * speed;\n      });\n      triangle.center.x += Math.cos(angle) * speed;\n      triangle.center.y += Math.sin(angle) * speed; // Vérifie la collision avec les cercles\n\n      model.circles.forEach(circle => {\n        if (coll.checkCollisionWithCircle(triangle, circle)) {\n          if (triangle.color === circle.color) {\n            circle.hp += 1; // Augmente les points de vie du cercle\n          } else {\n            circle.hp -= 1; // Réduit les points de vie du cercle\n\n            if (circle.hp <= 0) {\n              circle.color = triangle.color; // Change la couleur du cercle à celle du triangle\n\n              circle.hp = 10; // Réinitialise les points de vie\n            }\n          }\n\n          keepTriangle = false; // Supprime le triangle en cas de collision\n        } //keepTriangle = this.collisionsGestion(triangle, circle);\n\n\n        console.log(keepTriangle);\n      });\n    }\n\n    return keepTriangle; // Garde le triangle s'il n'y a pas de collision\n  });\n  return {\n    triangles: newtriangles,\n    circles: model.circles,\n    startSelec: model.startSelec,\n    endSelec: model.endSelec,\n    events: model.events\n  };\n};\n\nexport const winGame = model => {\n  const colors = model.circles.map(circle => circle.color);\n  return colors.every(color => color === conf.PLAYERCOLOR);\n};\nexport const loseGame = model => {\n  const colors = model.circles.map(circle => circle.color);\n  return colors.every(color => color !== conf.PLAYERCOLOR);\n};\n/*******************************************************************\n     * Fonctions pour les événements\n*******************************************************************/\n\nexport const setDestination = (model, destination) => {\n  // Définit la destination et initie le mouvement pour les triangles sélectionnés\n  const newtriangles = model.triangles.map(triangle => {\n    if (triangle.selected) {\n      return reorientTriangle({\n        points: triangle.points,\n        size: triangle.size,\n        center: triangle.center,\n        color: triangle.color,\n        selected: triangle.selected,\n        destination: destination\n      });\n    }\n\n    return triangle;\n  }); //return moveTriangles(model); // Commence le mouvement\n\n  return {\n    triangles: newtriangles,\n    circles: model.circles,\n    startSelec: model.startSelec,\n    endSelec: model.endSelec,\n    events: model.events\n  };\n};\n\nconst onleftclick = (model, destination) => {\n  return setDestination(model, destination);\n};\n\nconst onrightclick = (model, start) => {\n  return {\n    triangles: model.triangles,\n    circles: model.circles,\n    startSelec: start,\n    endSelec: null,\n    events: model.events\n  };\n};\n\nconst onmousemove = (model, end) => {\n  return {\n    triangles: model.triangles,\n    circles: model.circles,\n    startSelec: model.startSelec,\n    endSelec: end,\n    events: model.events\n  };\n};\n\nconst onmouseup = model => {\n  if (!model.startSelec || !model.endSelec) return model; // Aucune sélection en cours // Impossible normalement\n\n  return selectTrianglesInArea(model.startSelec, model.endSelec, model);\n};\n\nconst executeEvents = model => {\n  const newmodel = model.events.reduce((acc, event) => {\n    switch (event.type) {\n      case 'click':\n        return onleftclick(acc, {\n          x: event.offsetX,\n          y: event.offsetY\n        });\n\n      case 'mousedown':\n        return onrightclick(acc, {\n          x: event.offsetX,\n          y: event.offsetY\n        });\n\n      case 'mousemove':\n        return onmousemove(acc, {\n          x: event.offsetX,\n          y: event.offsetY\n        });\n\n      case 'mouseup':\n        return onmouseup(acc);\n\n      default:\n        return acc;\n    }\n  }, model);\n  return {\n    triangles: newmodel.triangles,\n    circles: newmodel.circles,\n    startSelec: newmodel.startSelec,\n    endSelec: newmodel.endSelec,\n    events: []\n  };\n};\n\nexport const addEvent = (model, event) => {\n  return {\n    triangles: model.triangles,\n    circles: model.circles,\n    startSelec: model.startSelec,\n    endSelec: model.endSelec,\n    events: model.events.concat(event)\n  };\n};\nexport const updateModel = model => {\n  const newModel = executeEvents(model);\n  return moveTriangles(newModel);\n}; // Fonction de tests, génération de triangles et cercles\n\nconst generateTriangles = (model, number) => {\n  for (let i = 0; i < number; i++) {\n    const x = Math.random() * 800 + 200;\n    const y = Math.random() * 200;\n    const size = 20;\n    const points = [{\n      x: x,\n      y: y - size\n    }, {\n      x: x - size,\n      y: y + size\n    }, {\n      x: x + size,\n      y: y + size\n    }];\n    const center = {\n      x: x,\n      y: y\n    };\n    const color = conf.ENEMYCOLOR1;\n    const triangle = {\n      points: points,\n      size: size,\n      center: center,\n      color: color,\n      selected: false,\n      destination: null\n    };\n    model = addTriangle(model, triangle);\n  }\n\n  return model;\n};\n\nconst generateCircles = model => {\n  const x = 100;\n  const y = 100;\n  const radius = conf.MEDIUMPLANETRADIUS;\n  const center = {\n    x: x,\n    y: y\n  };\n  const color = conf.ENEMYCOLOR1;\n  const hp = conf.BIGPLANETLIFE;\n  const circle = {\n    center: center,\n    radius: radius,\n    color: color,\n    hp: hp\n  };\n  model = addCircle(model, circle);\n  const x2 = 300;\n  const y2 = 300;\n  const radius2 = conf.BIGPLANETRADIUS;\n  const center2 = {\n    x: x2,\n    y: y2\n  };\n  const color2 = conf.PLAYERCOLOR;\n  const hp2 = conf.BIGPLANETLIFE;\n  const circle2 = {\n    center: center2,\n    radius: radius2,\n    color: color2,\n    hp: hp2\n  };\n  model = addCircle(model, circle2);\n  return model;\n};\n\nexport const createGameTest = () => {\n  let model = initModel();\n  model = generateTriangles(model, 10000);\n  model = generateCircles(model);\n  return model;\n};","map":{"version":3,"sources":["/home/ewen/Desktop/CPA_PROJETS/CPA_Projet/Version_fonctionnelle/src/components/Canvas/model.ts"],"names":["coll","conf","initModel","triangles","circles","startSelec","endSelec","events","addTriangle","model","triangle","concat","addCircle","circle","selectTrianglesInArea","start","end","modele","selectionRect","x1","Math","min","x","y1","y","x2","max","y2","newtriangles","map","centerX","center","centerY","selected","newTriangle","points","size","color","destination","reorientTriangle","angleToDestination","atan2","currentTop","angleCurrentTop","rotationAngle","newpoints","point","dx","dy","cos","sin","collisionsGestion","collision","checkCollisionWithCircle","hp","console","log","moveTriangles","filter","keepTriangle","distance","sqrt","angle","speed","forEach","winGame","colors","every","PLAYERCOLOR","loseGame","setDestination","onleftclick","onrightclick","onmousemove","onmouseup","executeEvents","newmodel","reduce","acc","event","type","offsetX","offsetY","addEvent","updateModel","newModel","generateTriangles","number","i","random","ENEMYCOLOR1","generateCircles","radius","MEDIUMPLANETRADIUS","BIGPLANETLIFE","radius2","BIGPLANETRADIUS","center2","color2","hp2","circle2","createGameTest"],"mappings":"AAAA,OAAO,KAAKA,IAAZ,MAAsB,aAAtB;AACA,OAAO,KAAKC,IAAZ,MAAsB,QAAtB;AA4BA,OAAO,MAAMC,SAAS,GAAG,MAAgB;AACrC,SAAO;AAAEC,IAAAA,SAAS,EAAE,EAAb;AAAiBC,IAAAA,OAAO,EAAE,EAA1B;AAA8BC,IAAAA,UAAU,EAAE,IAA1C;AAAgDC,IAAAA,QAAQ,EAAE,IAA1D;AAAgEC,IAAAA,MAAM,EAAE;AAAxE,GAAP;AACH,CAFM,C,CAIP;;AACA,MAAMC,WAAW,GAAG,CAACC,KAAD,EAAkBC,QAAlB,KAAmD;AACnE,SAAO;AACHP,IAAAA,SAAS,EAAEM,KAAK,CAACN,SAAN,CAAgBQ,MAAhB,CAAuBD,QAAvB,CADR;AAEHN,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAFZ;AAGHC,IAAAA,UAAU,EAAEI,KAAK,CAACJ,UAHf;AAIHC,IAAAA,QAAQ,EAAEG,KAAK,CAACH,QAJb;AAKHC,IAAAA,MAAM,EAAEE,KAAK,CAACF;AALX,GAAP;AAOH,CARD;;AAUA,MAAMK,SAAS,GAAG,CAACH,KAAD,EAAkBI,MAAlB,KAA+C;AAC7D,SAAO;AACHV,IAAAA,SAAS,EAAEM,KAAK,CAACN,SADd;AAEHC,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAAN,CAAcO,MAAd,CAAqBE,MAArB,CAFN;AAGHR,IAAAA,UAAU,EAAEI,KAAK,CAACJ,UAHf;AAIHC,IAAAA,QAAQ,EAAEG,KAAK,CAACH,QAJb;AAKHC,IAAAA,MAAM,EAAEE,KAAK,CAACF;AALX,GAAP;AAOH,CARD;AAYA;AACA;AACA;;;AACA,OAAO,MAAMO,qBAAqB,GAAG,CAACC,KAAD,EAAgBC,GAAhB,EAA6BC,MAA7B,KAAmD;AACpF;AACA,QAAMC,aAAa,GAAG;AAClBC,IAAAA,EAAE,EAAEC,IAAI,CAACC,GAAL,CAASN,KAAK,CAACO,CAAf,EAAkBN,GAAG,CAACM,CAAtB,CADc;AAElBC,IAAAA,EAAE,EAAEH,IAAI,CAACC,GAAL,CAASN,KAAK,CAACS,CAAf,EAAkBR,GAAG,CAACQ,CAAtB,CAFc;AAGlBC,IAAAA,EAAE,EAAEL,IAAI,CAACM,GAAL,CAASX,KAAK,CAACO,CAAf,EAAkBN,GAAG,CAACM,CAAtB,CAHc;AAIlBK,IAAAA,EAAE,EAAEP,IAAI,CAACM,GAAL,CAASX,KAAK,CAACS,CAAf,EAAkBR,GAAG,CAACQ,CAAtB;AAJc,GAAtB;AAOA,QAAMI,YAAY,GAAGX,MAAM,CAACd,SAAP,CAAiB0B,GAAjB,CAAqBnB,QAAQ,IAAI;AAClD,UAAMoB,OAAO,GAAGpB,QAAQ,CAACqB,MAAT,CAAgBT,CAAhC;AACA,UAAMU,OAAO,GAAGtB,QAAQ,CAACqB,MAAT,CAAgBP,CAAhC;AACA,UAAMS,QAAQ,GAAGH,OAAO,IAAIZ,aAAa,CAACC,EAAzB,IAA+BW,OAAO,IAAIZ,aAAa,CAACO,EAAxD,IACGO,OAAO,IAAId,aAAa,CAACK,EAD5B,IACkCS,OAAO,IAAId,aAAa,CAACS,EAD5E,CAHkD,CAKlD;;AACA,UAAMO,WAAuB,GAAG;AAC5BC,MAAAA,MAAM,EAAGzB,QAAQ,CAACyB,MADU;AAE5BC,MAAAA,IAAI,EAAG1B,QAAQ,CAAC0B,IAFY;AAG5BL,MAAAA,MAAM,EAAGrB,QAAQ,CAACqB,MAHU;AAI5BM,MAAAA,KAAK,EAAG3B,QAAQ,CAAC2B,KAJW;AAK5BJ,MAAAA,QAAQ,EAAGA,QALiB;AAM5BK,MAAAA,WAAW,EAAI5B,QAAQ,CAAC4B;AANI,KAAhC;AAQA,WAAOJ,WAAP;AACH,GAfoB,CAArB;AAgBA,SAAO;AACH/B,IAAAA,SAAS,EAAEyB,YADR;AAEHxB,IAAAA,OAAO,EAAEa,MAAM,CAACb,OAFb;AAGHC,IAAAA,UAAU,EAAE,IAHT;AAIHC,IAAAA,QAAQ,EAAE,IAJP;AAKHC,IAAAA,MAAM,EAAEU,MAAM,CAACV;AALZ,GAAP;AAOH,CAhCM,C,CAkCP;;AACA,MAAMgC,gBAAgB,GAAI7B,QAAD,IAAmC;AACxD,QAAMqB,MAAM,GAAGrB,QAAQ,CAACqB,MAAxB,CADwD,CACxB;;AAChC,QAAMO,WAAW,GAAG5B,QAAQ,CAAC4B,WAA7B,CAFwD,CAIxD;;AACA,MAAI,CAACA,WAAL,EAAkB,OAAO5B,QAAP,CALsC,CAMxD;;AACA,QAAM8B,kBAAkB,GAAGpB,IAAI,CAACqB,KAAL,CAAWH,WAAW,CAACd,CAAZ,GAAgBO,MAAM,CAACP,CAAlC,EAAqCc,WAAW,CAAChB,CAAZ,GAAgBS,MAAM,CAACT,CAA5D,CAA3B,CAPwD,CASxD;;AACA,QAAMoB,UAAU,GAAGhC,QAAQ,CAACyB,MAAT,CAAgB,CAAhB,CAAnB,CAVwD,CAUjB;;AACvC,QAAMQ,eAAe,GAAGvB,IAAI,CAACqB,KAAL,CAAWC,UAAU,CAAClB,CAAX,GAAeO,MAAM,CAACP,CAAjC,EAAoCkB,UAAU,CAACpB,CAAX,GAAeS,MAAM,CAACT,CAA1D,CAAxB,CAXwD,CAaxD;;AACA,MAAIsB,aAAa,GAAGJ,kBAAkB,GAAGG,eAAzC,CAdwD,CAgBxD;;AACA,QAAME,SAAS,GAAGnC,QAAQ,CAACyB,MAAT,CAAgBN,GAAhB,CAAoBiB,KAAK,IAAI;AAC3C,UAAMC,EAAE,GAAGD,KAAK,CAACxB,CAAN,GAAUS,MAAM,CAACT,CAA5B;AACA,UAAM0B,EAAE,GAAGF,KAAK,CAACtB,CAAN,GAAUO,MAAM,CAACP,CAA5B;AAEA,WAAO;AACHF,MAAAA,CAAC,EAAES,MAAM,CAACT,CAAP,GAAWyB,EAAE,GAAG3B,IAAI,CAAC6B,GAAL,CAASL,aAAT,CAAhB,GAA0CI,EAAE,GAAG5B,IAAI,CAAC8B,GAAL,CAASN,aAAT,CAD/C;AAEHpB,MAAAA,CAAC,EAAEO,MAAM,CAACP,CAAP,GAAWuB,EAAE,GAAG3B,IAAI,CAAC8B,GAAL,CAASN,aAAT,CAAhB,GAA0CI,EAAE,GAAG5B,IAAI,CAAC6B,GAAL,CAASL,aAAT;AAF/C,KAAP;AAIH,GARiB,CAAlB;AAUA,QAAMV,WAAuB,GAAG;AAC5BC,IAAAA,MAAM,EAAGU,SADmB;AAE5BT,IAAAA,IAAI,EAAG1B,QAAQ,CAAC0B,IAFY;AAG5BL,IAAAA,MAAM,EAAGrB,QAAQ,CAACqB,MAHU;AAI5BM,IAAAA,KAAK,EAAG3B,QAAQ,CAAC2B,KAJW;AAK5BJ,IAAAA,QAAQ,EAAGvB,QAAQ,CAACuB,QALQ;AAM5BK,IAAAA,WAAW,EAAI5B,QAAQ,CAAC4B;AANI,GAAhC;AAQA,SAAOJ,WAAP;AACH,CApCD;;AAuCA,MAAMiB,iBAAiB,GAAG,CAACzC,QAAD,EAAsBG,MAAtB,KAA0C;AAChE,MAAI,KAAKuC,SAAL,CAAeC,wBAAf,CAAwC3C,QAAxC,EAAkDG,MAAlD,CAAJ,EAA+D;AAC3D,QAAIH,QAAQ,CAAC2B,KAAT,KAAmBxB,MAAM,CAACwB,KAA9B,EAAqC;AACjCxB,MAAAA,MAAM,CAACyC,EAAP,IAAa,CAAb,CADiC,CACjB;;AAChBC,MAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACH,KAHD,MAIK;AACD3C,MAAAA,MAAM,CAACyC,EAAP,IAAa,CAAb,CADC,CACe;;AAChB,UAAIzC,MAAM,CAACyC,EAAP,IAAa,CAAjB,EAAoB;AAChBzC,QAAAA,MAAM,CAACwB,KAAP,GAAe3B,QAAQ,CAAC2B,KAAxB,CADgB,CACe;;AAC/BxB,QAAAA,MAAM,CAACyC,EAAP,GAAY,EAAZ,CAFgB,CAEA;AACnB;;AACDC,MAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ;AACH,KAZ0D,CAa3D;;;AACA,WAAO,KAAP,CAd2D,CAc7C;AACjB,GAfD,MAgBK,OAAO,IAAP,CAjB2D,CAiB9C;;AACrB,CAlBD;;AAoBA,MAAMC,aAAa,GAAIhD,KAAD,IAAkC;AACpD,QAAMmB,YAAY,GAAGnB,KAAK,CAACN,SAAN,CAAgBuD,MAAhB,CAAuBhD,QAAQ,IAAI;AACpD,QAAIiD,YAAY,GAAG,IAAnB;;AACA,QAAIjD,QAAQ,CAAC4B,WAAb,EAAyB;AAAE;AAEvB;AACA,YAAMS,EAAE,GAAGrC,QAAQ,CAAC4B,WAAT,CAAqBhB,CAArB,GAAyBZ,QAAQ,CAACqB,MAAT,CAAgBT,CAApD;AACA,YAAM0B,EAAE,GAAGtC,QAAQ,CAAC4B,WAAT,CAAqBd,CAArB,GAAyBd,QAAQ,CAACqB,MAAT,CAAgBP,CAApD;AACA,YAAMoC,QAAQ,GAAGxC,IAAI,CAACyC,IAAL,CAAUd,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,CAAjB;AACA,YAAMc,KAAK,GAAG1C,IAAI,CAACqB,KAAL,CAAWO,EAAX,EAAeD,EAAf,CAAd;;AAEA,UAAIa,QAAQ,GAAG,CAAf,EAAkB;AACdlD,QAAAA,QAAQ,CAAC4B,WAAT,GAAuB,IAAvB,CADc,CACe;;AAC7B,eAAOqB,YAAP,CAFc,CAEO;AACxB;;AAED,YAAMI,KAAK,GAAG,CAAd,CAbqB,CAaJ;;AACjBrD,MAAAA,QAAQ,CAACyB,MAAT,CAAgB6B,OAAhB,CAAwBlB,KAAK,IAAI;AAC7BA,QAAAA,KAAK,CAACxB,CAAN,IAAWF,IAAI,CAAC6B,GAAL,CAASa,KAAT,IAAkBC,KAA7B;AACAjB,QAAAA,KAAK,CAACtB,CAAN,IAAWJ,IAAI,CAAC8B,GAAL,CAASY,KAAT,IAAkBC,KAA7B;AACH,OAHD;AAIArD,MAAAA,QAAQ,CAACqB,MAAT,CAAgBT,CAAhB,IAAqBF,IAAI,CAAC6B,GAAL,CAASa,KAAT,IAAkBC,KAAvC;AACArD,MAAAA,QAAQ,CAACqB,MAAT,CAAgBP,CAAhB,IAAqBJ,IAAI,CAAC8B,GAAL,CAASY,KAAT,IAAkBC,KAAvC,CAnBqB,CAsBrB;;AACAtD,MAAAA,KAAK,CAACL,OAAN,CAAc4D,OAAd,CAAsBnD,MAAM,IAAI;AAC5B,YAAIb,IAAI,CAACqD,wBAAL,CAA8B3C,QAA9B,EAAwCG,MAAxC,CAAJ,EAAqD;AACjD,cAAIH,QAAQ,CAAC2B,KAAT,KAAmBxB,MAAM,CAACwB,KAA9B,EAAqC;AACjCxB,YAAAA,MAAM,CAACyC,EAAP,IAAa,CAAb,CADiC,CACjB;AACnB,WAFD,MAGK;AACDzC,YAAAA,MAAM,CAACyC,EAAP,IAAa,CAAb,CADC,CACe;;AAChB,gBAAIzC,MAAM,CAACyC,EAAP,IAAa,CAAjB,EAAoB;AAChBzC,cAAAA,MAAM,CAACwB,KAAP,GAAe3B,QAAQ,CAAC2B,KAAxB,CADgB,CACe;;AAC/BxB,cAAAA,MAAM,CAACyC,EAAP,GAAY,EAAZ,CAFgB,CAEA;AACnB;AACJ;;AACDK,UAAAA,YAAY,GAAG,KAAf,CAXiD,CAW3B;AACzB,SAb2B,CAc5B;;;AACAJ,QAAAA,OAAO,CAACC,GAAR,CAAYG,YAAZ;AACH,OAhBD;AAiBH;;AACD,WAAOA,YAAP,CA3CoD,CA2C/B;AACxB,GA5CoB,CAArB;AA6CA,SAAO;AACHxD,IAAAA,SAAS,EAAEyB,YADR;AAEHxB,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAFZ;AAGHC,IAAAA,UAAU,EAAEI,KAAK,CAACJ,UAHf;AAIHC,IAAAA,QAAQ,EAAEG,KAAK,CAACH,QAJb;AAKHC,IAAAA,MAAM,EAAEE,KAAK,CAACF;AALX,GAAP;AAOH,CArDD;;AAuDA,OAAO,MAAM0D,OAAO,GAAIxD,KAAD,IAAgC;AACnD,QAAMyD,MAAM,GAAGzD,KAAK,CAACL,OAAN,CAAcyB,GAAd,CAAkBhB,MAAM,IAAIA,MAAM,CAACwB,KAAnC,CAAf;AACA,SAAO6B,MAAM,CAACC,KAAP,CAAa9B,KAAK,IAAIA,KAAK,KAAKpC,IAAI,CAACmE,WAArC,CAAP;AACH,CAHM;AAIP,OAAO,MAAMC,QAAQ,GAAI5D,KAAD,IAAgC;AACpD,QAAMyD,MAAM,GAAGzD,KAAK,CAACL,OAAN,CAAcyB,GAAd,CAAkBhB,MAAM,IAAIA,MAAM,CAACwB,KAAnC,CAAf;AACA,SAAO6B,MAAM,CAACC,KAAP,CAAa9B,KAAK,IAAIA,KAAK,KAAKpC,IAAI,CAACmE,WAArC,CAAP;AACH,CAHM;AAKP;AACA;AACA;;AACA,OAAO,MAAME,cAAc,GAAG,CAAC7D,KAAD,EAAmB6B,WAAnB,KAAsD;AAChF;AACA,QAAMV,YAAY,GAAGnB,KAAK,CAACN,SAAN,CAAgB0B,GAAhB,CAAoBnB,QAAQ,IAAI;AACjD,QAAIA,QAAQ,CAACuB,QAAb,EAAuB;AACnB,aAAOM,gBAAgB,CACnB;AAACJ,QAAAA,MAAM,EAAGzB,QAAQ,CAACyB,MAAnB;AACIC,QAAAA,IAAI,EAAG1B,QAAQ,CAAC0B,IADpB;AAEIL,QAAAA,MAAM,EAAGrB,QAAQ,CAACqB,MAFtB;AAGIM,QAAAA,KAAK,EAAG3B,QAAQ,CAAC2B,KAHrB;AAIIJ,QAAAA,QAAQ,EAAGvB,QAAQ,CAACuB,QAJxB;AAKIK,QAAAA,WAAW,EAAGA;AALlB,OADmB,CAAvB;AAQH;;AACD,WAAO5B,QAAP;AACH,GAZoB,CAArB,CAFgF,CAgBhF;;AACA,SAAO;AACHP,IAAAA,SAAS,EAAEyB,YADR;AAEHxB,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAFZ;AAGHC,IAAAA,UAAU,EAAEI,KAAK,CAACJ,UAHf;AAIHC,IAAAA,QAAQ,EAAEG,KAAK,CAACH,QAJb;AAKHC,IAAAA,MAAM,EAAEE,KAAK,CAACF;AALX,GAAP;AAOH,CAxBM;;AA0BP,MAAMgE,WAAW,GAAG,CAAC9D,KAAD,EAAmB6B,WAAnB,KAAsD;AACtE,SAAOgC,cAAc,CAAC7D,KAAD,EAAQ6B,WAAR,CAArB;AACH,CAFD;;AAIA,MAAMkC,YAAY,GAAG,CAAC/D,KAAD,EAAmBM,KAAnB,KAAgD;AACjE,SAAO;AACHZ,IAAAA,SAAS,EAAEM,KAAK,CAACN,SADd;AAEHC,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAFZ;AAGHC,IAAAA,UAAU,EAAEU,KAHT;AAIHT,IAAAA,QAAQ,EAAE,IAJP;AAKHC,IAAAA,MAAM,EAAEE,KAAK,CAACF;AALX,GAAP;AAOH,CARD;;AAUA,MAAMkE,WAAW,GAAG,CAAChE,KAAD,EAAmBO,GAAnB,KAA8C;AAC9D,SAAO;AACHb,IAAAA,SAAS,EAAEM,KAAK,CAACN,SADd;AAEHC,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAFZ;AAGHC,IAAAA,UAAU,EAAEI,KAAK,CAACJ,UAHf;AAIHC,IAAAA,QAAQ,EAAEU,GAJP;AAKHT,IAAAA,MAAM,EAAEE,KAAK,CAACF;AALX,GAAP;AAOH,CARD;;AAUA,MAAMmE,SAAS,GAAIjE,KAAD,IAAiC;AAC/C,MAAI,CAACA,KAAK,CAACJ,UAAP,IAAqB,CAACI,KAAK,CAACH,QAAhC,EAA0C,OAAOG,KAAP,CADK,CACS;;AACxD,SAAOK,qBAAqB,CAACL,KAAK,CAACJ,UAAP,EAAmBI,KAAK,CAACH,QAAzB,EAAmCG,KAAnC,CAA5B;AACH,CAHD;;AAKA,MAAMkE,aAAa,GAAIlE,KAAD,IAAiC;AACnD,QAAMmE,QAAQ,GAAGnE,KAAK,CAACF,MAAN,CAAasE,MAAb,CAAoB,CAACC,GAAD,EAAMC,KAAN,KAAgB;AACjD,YAAQA,KAAK,CAACC,IAAd;AACI,WAAK,OAAL;AACI,eAAOT,WAAW,CAACO,GAAD,EAAM;AAAExD,UAAAA,CAAC,EAAEyD,KAAK,CAACE,OAAX;AAAoBzD,UAAAA,CAAC,EAAEuD,KAAK,CAACG;AAA7B,SAAN,CAAlB;;AACJ,WAAK,WAAL;AACI,eAAOV,YAAY,CAACM,GAAD,EAAM;AAAExD,UAAAA,CAAC,EAAEyD,KAAK,CAACE,OAAX;AAAoBzD,UAAAA,CAAC,EAAEuD,KAAK,CAACG;AAA7B,SAAN,CAAnB;;AACJ,WAAK,WAAL;AACI,eAAOT,WAAW,CAACK,GAAD,EAAM;AAAExD,UAAAA,CAAC,EAAEyD,KAAK,CAACE,OAAX;AAAoBzD,UAAAA,CAAC,EAAEuD,KAAK,CAACG;AAA7B,SAAN,CAAlB;;AACJ,WAAK,SAAL;AACI,eAAOR,SAAS,CAACI,GAAD,CAAhB;;AACJ;AACI,eAAOA,GAAP;AAVR;AAYH,GAbgB,EAadrE,KAbc,CAAjB;AAcA,SAAO;AACHN,IAAAA,SAAS,EAAEyE,QAAQ,CAACzE,SADjB;AAEHC,IAAAA,OAAO,EAAEwE,QAAQ,CAACxE,OAFf;AAGHC,IAAAA,UAAU,EAAEuE,QAAQ,CAACvE,UAHlB;AAIHC,IAAAA,QAAQ,EAAEsE,QAAQ,CAACtE,QAJhB;AAKHC,IAAAA,MAAM,EAAE;AALL,GAAP;AAOH,CAtBD;;AAwBA,OAAO,MAAM4E,QAAQ,GAAG,CAAC1E,KAAD,EAAmBsE,KAAnB,KAAqD;AACzE,SAAO;AACH5E,IAAAA,SAAS,EAAEM,KAAK,CAACN,SADd;AAEHC,IAAAA,OAAO,EAAEK,KAAK,CAACL,OAFZ;AAGHC,IAAAA,UAAU,EAAEI,KAAK,CAACJ,UAHf;AAIHC,IAAAA,QAAQ,EAAEG,KAAK,CAACH,QAJb;AAKHC,IAAAA,MAAM,EAAEE,KAAK,CAACF,MAAN,CAAaI,MAAb,CAAoBoE,KAApB;AALL,GAAP;AAOH,CARM;AAUP,OAAO,MAAMK,WAAW,GAAI3E,KAAD,IAAiC;AACxD,QAAM4E,QAAQ,GAAGV,aAAa,CAAClE,KAAD,CAA9B;AACA,SAAOgD,aAAa,CAAC4B,QAAD,CAApB;AACH,CAHM,C,CAKP;;AACA,MAAMC,iBAAiB,GAAG,CAAC7E,KAAD,EAAmB8E,MAAnB,KAAkD;AACxE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC7B,UAAMlE,CAAC,GAAGF,IAAI,CAACqE,MAAL,KAAgB,GAAhB,GAAoB,GAA9B;AACA,UAAMjE,CAAC,GAAGJ,IAAI,CAACqE,MAAL,KAAgB,GAA1B;AACA,UAAMrD,IAAI,GAAG,EAAb;AACA,UAAMD,MAAM,GAAG,CACX;AAAEb,MAAAA,CAAC,EAAEA,CAAL;AAAQE,MAAAA,CAAC,EAAEA,CAAC,GAAGY;AAAf,KADW,EAEX;AAAEd,MAAAA,CAAC,EAAEA,CAAC,GAAGc,IAAT;AAAeZ,MAAAA,CAAC,EAAEA,CAAC,GAAGY;AAAtB,KAFW,EAGX;AAAEd,MAAAA,CAAC,EAAEA,CAAC,GAAGc,IAAT;AAAeZ,MAAAA,CAAC,EAAEA,CAAC,GAAGY;AAAtB,KAHW,CAAf;AAKA,UAAML,MAAM,GAAG;AAAET,MAAAA,CAAC,EAAEA,CAAL;AAAQE,MAAAA,CAAC,EAAEA;AAAX,KAAf;AACA,UAAMa,KAAK,GAAGpC,IAAI,CAACyF,WAAnB;AACA,UAAMhF,QAAmB,GAAG;AACxByB,MAAAA,MAAM,EAAGA,MADe;AAExBC,MAAAA,IAAI,EAAGA,IAFiB;AAGxBL,MAAAA,MAAM,EAAGA,MAHe;AAIxBM,MAAAA,KAAK,EAAGA,KAJgB;AAKxBJ,MAAAA,QAAQ,EAAG,KALa;AAMxBK,MAAAA,WAAW,EAAG;AANU,KAA5B;AAQA7B,IAAAA,KAAK,GAAGD,WAAW,CAACC,KAAD,EAAQC,QAAR,CAAnB;AACH;;AACD,SAAOD,KAAP;AACH,CAvBD;;AAwBA,MAAMkF,eAAe,GAAIlF,KAAD,IAAiC;AACrD,QAAMa,CAAC,GAAG,GAAV;AACA,QAAME,CAAC,GAAG,GAAV;AACA,QAAMoE,MAAM,GAAG3F,IAAI,CAAC4F,kBAApB;AACA,QAAM9D,MAAM,GAAG;AAAET,IAAAA,CAAC,EAAEA,CAAL;AAAQE,IAAAA,CAAC,EAAEA;AAAX,GAAf;AACA,QAAMa,KAAK,GAAGpC,IAAI,CAACyF,WAAnB;AACA,QAAMpC,EAAE,GAAGrD,IAAI,CAAC6F,aAAhB;AACA,QAAMjF,MAAe,GAAG;AAAEkB,IAAAA,MAAM,EAAEA,MAAV;AAAkB6D,IAAAA,MAAM,EAAEA,MAA1B;AAAkCvD,IAAAA,KAAK,EAAEA,KAAzC;AAAgDiB,IAAAA,EAAE,EAAEA;AAApD,GAAxB;AACA7C,EAAAA,KAAK,GAAGG,SAAS,CAACH,KAAD,EAAQI,MAAR,CAAjB;AAEA,QAAMY,EAAE,GAAG,GAAX;AACA,QAAME,EAAE,GAAG,GAAX;AACA,QAAMoE,OAAO,GAAG9F,IAAI,CAAC+F,eAArB;AACA,QAAMC,OAAO,GAAG;AAAE3E,IAAAA,CAAC,EAAEG,EAAL;AAASD,IAAAA,CAAC,EAAEG;AAAZ,GAAhB;AACA,QAAMuE,MAAM,GAAGjG,IAAI,CAACmE,WAApB;AACA,QAAM+B,GAAG,GAAGlG,IAAI,CAAC6F,aAAjB;AACA,QAAMM,OAAgB,GAAG;AAAErE,IAAAA,MAAM,EAAEkE,OAAV;AAAmBL,IAAAA,MAAM,EAAEG,OAA3B;AAAoC1D,IAAAA,KAAK,EAAE6D,MAA3C;AAAmD5C,IAAAA,EAAE,EAAE6C;AAAvD,GAAzB;AACA1F,EAAAA,KAAK,GAAGG,SAAS,CAACH,KAAD,EAAQ2F,OAAR,CAAjB;AAEA,SAAO3F,KAAP;AACH,CApBD;;AAsBA,OAAO,MAAM4F,cAAc,GAAG,MAAM;AAChC,MAAI5F,KAAK,GAAGP,SAAS,EAArB;AACAO,EAAAA,KAAK,GAAG6E,iBAAiB,CAAC7E,KAAD,EAAQ,KAAR,CAAzB;AACAA,EAAAA,KAAK,GAAGkF,eAAe,CAAClF,KAAD,CAAvB;AACA,SAAOA,KAAP;AACH,CALM","sourcesContent":["import * as coll from \"./collision\";\nimport * as conf from \"./conf\";\n\n\n\nexport type Point = { x: number, y: number };\nexport type Triangle = {\n    points : Point[],\n    size : number, \n    center : Point ,\n    color: string, \n    selected: boolean, \n    destination: Point | null\n};\nexport type Circle = { \n    center: Point,\n    radius: number, \n    color: string, \n    hp : number\n};\nexport type OurModel = { \n    triangles: Triangle[], \n    circles: Circle[]\n    startSelec: Point | null,\n    endSelec: Point | null,\n    events : MouseEvent[]\n};\n\n\nexport const initModel = (): OurModel => {\n    return { triangles: [], circles: [], startSelec: null, endSelec: null, events: [] };\n}\n\n// Fonctions pour creer et ajouter des triangles et cercles dans le modele\nconst addTriangle = (model: OurModel, triangle: Triangle): OurModel => {\n    return {\n        triangles: model.triangles.concat(triangle), \n        circles: model.circles, \n        startSelec: model.startSelec, \n        endSelec: model.endSelec,\n        events: model.events\n    };\n}\n\nconst addCircle = (model: OurModel, circle: Circle): OurModel => {\n    return { \n        triangles: model.triangles, \n        circles: model.circles.concat(circle), \n        startSelec: model.startSelec, \n        endSelec: model.endSelec,\n        events: model.events\n    };\n}\n\n\n\n/*******************************************************************\n     * Fonctions de déplacement\n*******************************************************************/\nexport const selectTrianglesInArea = (start : Point, end : Point, modele : OurModel) => {\n    // Sélectionne les triangles dans la zone spécifiée par l'utilisateur\n    const selectionRect = {\n        x1: Math.min(start.x, end.x),\n        y1: Math.min(start.y, end.y),\n        x2: Math.max(start.x, end.x),\n        y2: Math.max(start.y, end.y)\n    };\n\n    const newtriangles = modele.triangles.map(triangle => {\n        const centerX = triangle.center.x;\n        const centerY = triangle.center.y;\n        const selected = centerX >= selectionRect.x1 && centerX <= selectionRect.x2 &&\n                            centerY >= selectionRect.y1 && centerY <= selectionRect.y2;\n        //if (triangle.destination == null) return createTriangle(triangle.points, triangle.size, triangle.center, triangle.color, selected, null);\n        const newTriangle :  Triangle = {\n            points : triangle.points,\n            size : triangle.size, \n            center : triangle.center, \n            color : triangle.color, \n            selected : selected, \n            destination :  triangle.destination\n        };\n        return newTriangle;\n    });\n    return { \n        triangles: newtriangles, \n        circles: modele.circles, \n        startSelec: null, \n        endSelec: null, \n        events: modele.events\n    };\n}\n\n// Réoriente le triangle pour qu'il pointe vers la destination\nconst reorientTriangle = (triangle : Triangle) : Triangle=> {\n    const center = triangle.center; // Utilisez le centre précalculé pour la rotation\n    const destination = triangle.destination;\n\n    // Si aucune destination n'est définie, retournez le triangle tel quel théoriquement impossible mais vérification obligatoire\n    if (!destination) return triangle;\n    // Calculez l'angle de direction vers la destination\n    const angleToDestination = Math.atan2(destination.y - center.y, destination.x - center.x);\n\n    // Calculez l'angle actuel du sommet supérieur par rapport au centre\n    const currentTop = triangle.points[0]; // Le sommet supérieur est toujours le premier point\n    const angleCurrentTop = Math.atan2(currentTop.y - center.y, currentTop.x - center.x);\n\n    // Calculez l'angle de rotation nécessaire\n    let rotationAngle = angleToDestination - angleCurrentTop;\n\n    // Appliquez la rotation à chaque point du triangle\n    const newpoints = triangle.points.map(point => {\n        const dx = point.x - center.x;\n        const dy = point.y - center.y;\n\n        return {\n            x: center.x + dx * Math.cos(rotationAngle) - dy * Math.sin(rotationAngle),\n            y: center.y + dx * Math.sin(rotationAngle) + dy * Math.cos(rotationAngle)\n        };\n    });\n\n    const newTriangle :  Triangle = {\n        points : newpoints,\n        size : triangle.size, \n        center : triangle.center, \n        color : triangle.color, \n        selected : triangle.selected, \n        destination :  triangle.destination\n    };\n    return newTriangle;\n}\n\n\nconst collisionsGestion = (triangle : Triangle, circle : Circle) => {\n    if (this.collision.checkCollisionWithCircle(triangle, circle)) {\n        if (triangle.color === circle.color) {\n            circle.hp += 1; // Augmente les points de vie du cercle\n            console.log(\"test\");\n        }\n        else {\n            circle.hp -= 1; // Réduit les points de vie du cercle\n            if (circle.hp <= 0) {\n                circle.color = triangle.color; // Change la couleur du cercle à celle du triangle\n                circle.hp = 10; // Réinitialise les points de vie\n            }\n            console.log(\"test2\");\n        }\n        //console.log(this.checkCollisionWithCircle(triangle, circle));\n        return false; // Supprime le triangle en cas de collision\n    }\n    else return true; // Garde le triangle s'il n'y a pas de collision\n}\n\nconst moveTriangles = (model : OurModel ) : OurModel => {\n    const newtriangles = model.triangles.filter(triangle => {\n        let keepTriangle = true;\n        if (triangle.destination){ // Ignore les triangles non sélectionnés ou immobiles\n\n            // Calcul de la direction et de la distance vers la destination\n            const dx = triangle.destination.x - triangle.center.x;\n            const dy = triangle.destination.y - triangle.center.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            const angle = Math.atan2(dy, dx);\n\n            if (distance < 1) {\n                triangle.destination = null; // Réinitialise la destination\n                return keepTriangle; // Le triangle reste présent\n            }\n\n            const speed = 1; // Vitesse de déplacement\n            triangle.points.forEach(point => {\n                point.x += Math.cos(angle) * speed;\n                point.y += Math.sin(angle) * speed;\n            });\n            triangle.center.x += Math.cos(angle) * speed;\n            triangle.center.y += Math.sin(angle) * speed;\n            \n\n            // Vérifie la collision avec les cercles\n            model.circles.forEach(circle => {\n                if (coll.checkCollisionWithCircle(triangle, circle)) {\n                    if (triangle.color === circle.color) {\n                        circle.hp += 1; // Augmente les points de vie du cercle\n                    }\n                    else {\n                        circle.hp -= 1; // Réduit les points de vie du cercle\n                        if (circle.hp <= 0) {\n                            circle.color = triangle.color; // Change la couleur du cercle à celle du triangle\n                            circle.hp = 10; // Réinitialise les points de vie\n                        }\n                    }\n                    keepTriangle = false; // Supprime le triangle en cas de collision\n                }\n                //keepTriangle = this.collisionsGestion(triangle, circle);\n                console.log(keepTriangle);\n            });\n        }\n        return keepTriangle; // Garde le triangle s'il n'y a pas de collision\n    });\n    return { \n        triangles: newtriangles, \n        circles: model.circles, \n        startSelec: model.startSelec, \n        endSelec: model.endSelec, \n        events: model.events \n    };\n}\n\nexport const winGame = (model : OurModel) : boolean => {\n    const colors = model.circles.map(circle => circle.color);\n    return colors.every(color => color === conf.PLAYERCOLOR);\n}\nexport const loseGame = (model : OurModel) : boolean => {\n    const colors = model.circles.map(circle => circle.color);\n    return colors.every(color => color !== conf.PLAYERCOLOR);\n}\n\n/*******************************************************************\n     * Fonctions pour les événements\n*******************************************************************/\nexport const setDestination = (model : OurModel, destination : Point) : OurModel => {\n    // Définit la destination et initie le mouvement pour les triangles sélectionnés\n    const newtriangles = model.triangles.map(triangle => {\n        if (triangle.selected) {\n            return reorientTriangle(\n                {points : triangle.points, \n                    size : triangle.size, \n                    center : triangle.center, \n                    color : triangle.color, \n                    selected : triangle.selected, \n                    destination : destination\n                });\n        }\n        return triangle;\n    });\n    \n    //return moveTriangles(model); // Commence le mouvement\n    return {\n        triangles: newtriangles, \n        circles: model.circles, \n        startSelec: model.startSelec, \n        endSelec: model.endSelec, \n        events: model.events\n    };\n}\n\nconst onleftclick = (model : OurModel, destination : Point) : OurModel => {\n    return setDestination(model, destination);\n}\n\nconst onrightclick = (model : OurModel, start : Point) : OurModel => {\n    return { \n        triangles: model.triangles, \n        circles: model.circles, \n        startSelec: start, \n        endSelec: null, \n        events: model.events\n    };\n}\n\nconst onmousemove = (model : OurModel, end : Point) : OurModel => {\n    return { \n        triangles: model.triangles, \n        circles: model.circles, \n        startSelec: model.startSelec, \n        endSelec: end, \n        events: model.events\n    };\n}\n\nconst onmouseup = (model : OurModel) : OurModel => {\n    if (!model.startSelec || !model.endSelec) return model; // Aucune sélection en cours // Impossible normalement\n    return selectTrianglesInArea(model.startSelec, model.endSelec, model);\n}\n\nconst executeEvents = (model : OurModel) : OurModel => {\n    const newmodel = model.events.reduce((acc, event) => {\n        switch (event.type) {\n            case 'click':\n                return onleftclick(acc, { x: event.offsetX, y: event.offsetY });\n            case 'mousedown':\n                return onrightclick(acc, { x: event.offsetX, y: event.offsetY });\n            case 'mousemove':\n                return onmousemove(acc, { x: event.offsetX, y: event.offsetY });\n            case 'mouseup':\n                return onmouseup(acc);\n            default:\n                return acc;\n        }\n    }, model);\n    return { \n        triangles: newmodel.triangles, \n        circles: newmodel.circles, \n        startSelec: newmodel.startSelec, \n        endSelec: newmodel.endSelec, \n        events: []\n    };\n}\n\nexport const addEvent = (model : OurModel, event : MouseEvent) : OurModel => {\n    return { \n        triangles: model.triangles, \n        circles: model.circles, \n        startSelec: model.startSelec, \n        endSelec: model.endSelec, \n        events: model.events.concat(event)\n    };\n}\n\nexport const updateModel = (model : OurModel) : OurModel => {\n    const newModel = executeEvents(model);\n    return moveTriangles(newModel);\n}\n\n// Fonction de tests, génération de triangles et cercles\nconst generateTriangles = (model : OurModel, number : number) : OurModel => {\n    for (let i = 0; i < number; i++) {\n        const x = Math.random() * 800+200;\n        const y = Math.random() * 200;\n        const size = 20;\n        const points = [\n            { x: x, y: y - size },\n            { x: x - size, y: y + size },\n            { x: x + size, y: y + size }\n        ];\n        const center = { x: x, y: y };\n        const color = conf.ENEMYCOLOR1;\n        const triangle : Triangle = {\n            points : points, \n            size : size, \n            center : center, \n            color : color, \n            selected : false, \n            destination : null\n        };\n        model = addTriangle(model, triangle);\n    }\n    return model;\n}\nconst generateCircles = (model : OurModel) : OurModel => {\n    const x = 100;\n    const y = 100;\n    const radius = conf.MEDIUMPLANETRADIUS;\n    const center = { x: x, y: y };\n    const color = conf.ENEMYCOLOR1;\n    const hp = conf.BIGPLANETLIFE;\n    const circle : Circle = { center: center, radius: radius, color: color, hp: hp };\n    model = addCircle(model, circle);\n    \n    const x2 = 300;\n    const y2 = 300;\n    const radius2 = conf.BIGPLANETRADIUS;\n    const center2 = { x: x2, y: y2 };\n    const color2 = conf.PLAYERCOLOR;\n    const hp2 = conf.BIGPLANETLIFE;\n    const circle2 : Circle = { center: center2, radius: radius2, color: color2, hp: hp2 };\n    model = addCircle(model, circle2);\n\n    return model;\n}\n\nexport const createGameTest = () => {\n    let model = initModel();\n    model = generateTriangles(model, 10000);\n    model = generateCircles(model);\n    return model;\n}\n\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}