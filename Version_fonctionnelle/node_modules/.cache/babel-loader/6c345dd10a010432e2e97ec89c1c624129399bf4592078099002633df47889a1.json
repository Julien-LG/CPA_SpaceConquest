{"ast":null,"code":"/*******************************************************************\n     * Fonctions de collision\n*******************************************************************/\nconst friction = 0.99;\nconst velocity = {\n  x: 0,\n  y: 0\n};\nexport const segmentIntersectsCircle = (start, end, circle) => {\n  const d = {\n    x: end.x - start.x,\n    y: end.y - start.y\n  };\n  const f = {\n    x: start.x - circle.center.x,\n    y: start.y - circle.center.y\n  };\n  const a = d.x * d.x + d.y * d.y;\n  const b = 2 * (f.x * d.x + f.y * d.y);\n  const c = f.x * f.x + f.y * f.y - circle.radius * circle.radius;\n  const discriminant = b * b - 4 * a * c;\n\n  if (discriminant < 0) {\n    // Pas de collision\n    return false;\n  } else {\n    // Vérifie si au moins un point d'intersection est sur le segment de ligne\n    const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);\n\n    if (t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1) {\n      return true; // Collision détectée\n    }\n\n    return false;\n  }\n}; // Vérifie la collision entre un triangle et un cercle\n\nexport const checkCollisionWithCircle = (triangle, circle) => {\n  // Vérifie la collision entre chaque sommet du triangle et le cercle\n  for (let point of triangle.points) {\n    const dx = point.x - circle.center.x;\n    const dy = point.y - circle.center.y;\n\n    if (dx * dx + dy * dy < circle.radius ** 2) {\n      return true; // Collision détectée avec un sommet\n    }\n  } // Vérifie la collision entre les segments du triangle et le cercle\n\n\n  for (let i = 0; i < triangle.points.length; i++) {\n    const start = triangle.points[i];\n    const end = triangle.points[(i + 1) % triangle.points.length];\n\n    if (segmentIntersectsCircle(start, end, circle)) {\n      return true; // Collision détectée avec un segment\n    }\n  }\n\n  return false; // Aucune collision détectée\n}; // Fonctiosn de collision entre triangles A finir\n\n/*\nexport const checkCollisionWithTriangle = (triangle1, triangle2) => {\n    // Vérifie la collision entre chaque sommet du triangle 1 et le triangle 2\n    for (let point of triangle1.points) {\n        if (isPointInsideTriangle(point, triangle2)) {\n            return true; // Collision détectée avec un sommet\n        }\n    }\n\n    // Vérifie la collision entre chaque sommet du triangle 2 et le triangle 1\n    for (let point of triangle2.points) {\n        if (isPointInsideTriangle(point, triangle1)) {\n            return true; // Collision détectée avec un sommet\n        }\n    }\n\n    // Vérifie la collision entre les segments des triangles\n    for (let i = 0; i < triangle1.points.length; i++) {\n        const start = triangle1.points[i];\n        const end = triangle1.points[(i + 1) % triangle1.points.length];\n        if (segmentIntersectsTriangle(start, end, triangle2)) {\n            return true; // Collision détectée avec un segment\n        }\n    }\n    return false; // Aucune collision détectée\n}\n\n// Applique la vélocité aux triangles rouges et gère les collisions avec les bords du canvas\nexport const applyVelocityAndCheckBorders = (triangles) => {\n    velocity.x *= friction;\n    velocity.y *= friction;\n    triangles.forEach(triangle => {\n        triangle.points.forEach(point => {\n            point.x += velocity.x;\n            point.y += velocity.y;\n            // Inversion de la vélocité en cas de collision avec un bord pour simuler un rebond\n            if (point.x < 0 || point.x > canvas.width) velocity.x = -velocity.x;\n            if (point.y < 0 || point.y > canvas.height) velocity.y = -velocity.y;\n        });\n    });\n}\n*/","map":{"version":3,"sources":["/home/ewen/Desktop/CPA_PROJETS/CPA_Projet/Version_fonctionnelle/src/components/Canvas/collision.ts"],"names":["friction","velocity","x","y","segmentIntersectsCircle","start","end","circle","d","f","center","a","b","c","radius","discriminant","t1","Math","sqrt","t2","checkCollisionWithCircle","triangle","point","points","dx","dy","i","length"],"mappings":"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","sourcesContent":["import { Triangle, Circle, Point } from './model';\ntype Line = { start: Point, end: Point };\n/*******************************************************************\n     * Fonctions de collision\n*******************************************************************/\nconst friction = 0.99;\nconst velocity = { x: 0, y: 0 };\n\nexport const segmentIntersectsCircle = (start : Point, end : Point , circle : Circle) => {\n    const d = { x: end.x - start.x, y: end.y - start.y };\n    const f = { x: start.x - circle.center.x, y: start.y - circle.center.y };\n\n    const a = d.x * d.x + d.y * d.y;\n    const b = 2 * (f.x * d.x + f.y * d.y);\n    const c = (f.x * f.x + f.y * f.y) - circle.radius * circle.radius;\n\n    const discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        // Pas de collision\n        return false;\n    } else {\n        // Vérifie si au moins un point d'intersection est sur le segment de ligne\n        const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);\n        const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);\n        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n            return true; // Collision détectée\n        }\n        return false;\n    }\n}\n// Vérifie la collision entre un triangle et un cercle\nexport const checkCollisionWithCircle = (triangle : Triangle,circle : Circle) => {\n    // Vérifie la collision entre chaque sommet du triangle et le cercle\n    for (let point of triangle.points) {\n        const dx = point.x - circle.center.x;\n        const dy = point.y - circle.center.y;\n        if ((dx * dx + dy * dy) < circle.radius**2) {\n            return true; // Collision détectée avec un sommet\n        }\n    }\n\n    // Vérifie la collision entre les segments du triangle et le cercle\n    for (let i = 0; i < triangle.points.length; i++) {\n        const start = triangle.points[i];\n        const end = triangle.points[(i + 1) % triangle.points.length];\n        if (segmentIntersectsCircle(start, end, circle)) {\n            return true; // Collision détectée avec un segment\n        }\n    }\n\n    return false; // Aucune collision détectée\n}\n\n\n// Fonctiosn de collision entre triangles A finir\n/*\nexport const checkCollisionWithTriangle = (triangle1, triangle2) => {\n    // Vérifie la collision entre chaque sommet du triangle 1 et le triangle 2\n    for (let point of triangle1.points) {\n        if (isPointInsideTriangle(point, triangle2)) {\n            return true; // Collision détectée avec un sommet\n        }\n    }\n\n    // Vérifie la collision entre chaque sommet du triangle 2 et le triangle 1\n    for (let point of triangle2.points) {\n        if (isPointInsideTriangle(point, triangle1)) {\n            return true; // Collision détectée avec un sommet\n        }\n    }\n\n    // Vérifie la collision entre les segments des triangles\n    for (let i = 0; i < triangle1.points.length; i++) {\n        const start = triangle1.points[i];\n        const end = triangle1.points[(i + 1) % triangle1.points.length];\n        if (segmentIntersectsTriangle(start, end, triangle2)) {\n            return true; // Collision détectée avec un segment\n        }\n    }\n    return false; // Aucune collision détectée\n}\n\n// Applique la vélocité aux triangles rouges et gère les collisions avec les bords du canvas\nexport const applyVelocityAndCheckBorders = (triangles) => {\n    velocity.x *= friction;\n    velocity.y *= friction;\n    triangles.forEach(triangle => {\n        triangle.points.forEach(point => {\n            point.x += velocity.x;\n            point.y += velocity.y;\n            // Inversion de la vélocité en cas de collision avec un bord pour simuler un rebond\n            if (point.x < 0 || point.x > canvas.width) velocity.x = -velocity.x;\n            if (point.y < 0 || point.y > canvas.height) velocity.y = -velocity.y;\n        });\n    });\n}\n*/"]},"metadata":{},"sourceType":"module","externalDependencies":[]}